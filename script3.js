/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/asap/browser-asap.js":
/*!*******************************************!*\
  !*** ./node_modules/asap/browser-asap.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

    "use strict";


    // rawAsap provides everything we need except exception management.
    var rawAsap = __webpack_require__(/*! ./raw */ "./node_modules/asap/browser-raw.js");
    // RawTasks are recycled to reduce GC churn.
    var freeTasks = [];
    // We queue errors to ensure they are thrown in right order (FIFO).
    // Array-as-queue is good enough here, since we are just dealing with exceptions.
    var pendingErrors = [];
    var requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);
    
    function throwFirstError() {
        if (pendingErrors.length) {
            throw pendingErrors.shift();
        }
    }
    
    /**
     * Calls a task as soon as possible after returning, in its own event, with priority
     * over other events like animation, reflow, and repaint. An error thrown from an
     * event will not interrupt, nor even substantially slow down the processing of
     * other events, but will be rather postponed to a lower priority event.
     * @param {{call}} task A callable object, typically a function that takes no
     * arguments.
     */
    module.exports = asap;
    function asap(task) {
        var rawTask;
        if (freeTasks.length) {
            rawTask = freeTasks.pop();
        } else {
            rawTask = new RawTask();
        }
        rawTask.task = task;
        rawAsap(rawTask);
    }
    
    // We wrap tasks with recyclable task objects.  A task object implements
    // `call`, just like a function.
    function RawTask() {
        this.task = null;
    }
    
    // The sole purpose of wrapping the task is to catch the exception and recycle
    // the task object after its single use.
    RawTask.prototype.call = function () {
        try {
            this.task.call();
        } catch (error) {
            if (asap.onerror) {
                // This hook exists purely for testing purposes.
                // Its name will be periodically randomized to break any code that
                // depends on its existence.
                asap.onerror(error);
            } else {
                // In a web browser, exceptions are not fatal. However, to avoid
                // slowing down the queue of pending tasks, we rethrow the error in a
                // lower priority turn.
                pendingErrors.push(error);
                requestErrorThrow();
            }
        } finally {
            this.task = null;
            freeTasks[freeTasks.length] = this;
        }
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/asap/browser-raw.js":
    /*!******************************************!*\
      !*** ./node_modules/asap/browser-raw.js ***!
      \******************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    // Use the fastest means possible to execute a task in its own turn, with
    // priority over other events including IO, animation, reflow, and redraw
    // events in browsers.
    //
    // An exception thrown by a task will permanently interrupt the processing of
    // subsequent tasks. The higher level `asap` function ensures that if an
    // exception is thrown by a task, that the task queue will continue flushing as
    // soon as possible, but if you use `rawAsap` directly, you are responsible to
    // either ensure that no exceptions are thrown from your task, or to manually
    // call `rawAsap.requestFlush` if an exception is thrown.
    module.exports = rawAsap;
    function rawAsap(task) {
        if (!queue.length) {
            requestFlush();
            flushing = true;
        }
        // Equivalent to push, but avoids a function call.
        queue[queue.length] = task;
    }
    
    var queue = [];
    // Once a flush has been requested, no further calls to `requestFlush` are
    // necessary until the next `flush` completes.
    var flushing = false;
    // `requestFlush` is an implementation-specific method that attempts to kick
    // off a `flush` event as quickly as possible. `flush` will attempt to exhaust
    // the event queue before yielding to the browser's own event loop.
    var requestFlush;
    // The position of the next task to execute in the task queue. This is
    // preserved between calls to `flush` so that it can be resumed if
    // a task throws an exception.
    var index = 0;
    // If a task schedules additional tasks recursively, the task queue can grow
    // unbounded. To prevent memory exhaustion, the task queue will periodically
    // truncate already-completed tasks.
    var capacity = 1024;
    
    // The flush function processes all tasks that have been scheduled with
    // `rawAsap` unless and until one of those tasks throws an exception.
    // If a task throws an exception, `flush` ensures that its state will remain
    // consistent and will resume where it left off when called again.
    // However, `flush` does not make any arrangements to be called again if an
    // exception is thrown.
    function flush() {
        while (index < queue.length) {
            var currentIndex = index;
            // Advance the index before calling the task. This ensures that we will
            // begin flushing on the next task the task throws an error.
            index = index + 1;
            queue[currentIndex].call();
            // Prevent leaking memory for long chains of recursive calls to `asap`.
            // If we call `asap` within tasks scheduled by `asap`, the queue will
            // grow, but to avoid an O(n) walk for every task we execute, we don't
            // shift tasks off the queue after they have been executed.
            // Instead, we periodically shift 1024 tasks off the queue.
            if (index > capacity) {
                // Manually shift all values starting at the index back to the
                // beginning of the queue.
                for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
                    queue[scan] = queue[scan + index];
                }
                queue.length -= index;
                index = 0;
            }
        }
        queue.length = 0;
        index = 0;
        flushing = false;
    }
    
    // `requestFlush` is implemented using a strategy based on data collected from
    // every available SauceLabs Selenium web driver worker at time of writing.
    // https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593
    
    // Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that
    // have WebKitMutationObserver but not un-prefixed MutationObserver.
    // Must use `global` or `self` instead of `window` to work in both frames and web
    // workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.
    
    /* globals self */
    var scope = typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : self;
    var BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;
    
    // MutationObservers are desirable because they have high priority and work
    // reliably everywhere they are implemented.
    // They are implemented in all modern browsers.
    //
    // - Android 4-4.3
    // - Chrome 26-34
    // - Firefox 14-29
    // - Internet Explorer 11
    // - iPad Safari 6-7.1
    // - iPhone Safari 7-7.1
    // - Safari 6-7
    if (typeof BrowserMutationObserver === "function") {
        requestFlush = makeRequestCallFromMutationObserver(flush);
    
    // MessageChannels are desirable because they give direct access to the HTML
    // task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera
    // 11-12, and in web workers in many engines.
    // Although message channels yield to any queued rendering and IO tasks, they
    // would be better than imposing the 4ms delay of timers.
    // However, they do not work reliably in Internet Explorer or Safari.
    
    // Internet Explorer 10 is the only browser that has setImmediate but does
    // not have MutationObservers.
    // Although setImmediate yields to the browser's renderer, it would be
    // preferrable to falling back to setTimeout since it does not have
    // the minimum 4ms penalty.
    // Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and
    // Desktop to a lesser extent) that renders both setImmediate and
    // MessageChannel useless for the purposes of ASAP.
    // https://github.com/kriskowal/q/issues/396
    
    // Timers are implemented universally.
    // We fall back to timers in workers in most engines, and in foreground
    // contexts in the following browsers.
    // However, note that even this simple case requires nuances to operate in a
    // broad spectrum of browsers.
    //
    // - Firefox 3-13
    // - Internet Explorer 6-9
    // - iPad Safari 4.3
    // - Lynx 2.8.7
    } else {
        requestFlush = makeRequestCallFromTimer(flush);
    }
    
    // `requestFlush` requests that the high priority event queue be flushed as
    // soon as possible.
    // This is useful to prevent an error thrown in a task from stalling the event
    // queue if the exception handled by Node.js’s
    // `process.on("uncaughtException")` or by a domain.
    rawAsap.requestFlush = requestFlush;
    
    // To request a high priority event, we induce a mutation observer by toggling
    // the text of a text node between "1" and "-1".
    function makeRequestCallFromMutationObserver(callback) {
        var toggle = 1;
        var observer = new BrowserMutationObserver(callback);
        var node = document.createTextNode("");
        observer.observe(node, {characterData: true});
        return function requestCall() {
            toggle = -toggle;
            node.data = toggle;
        };
    }
    
    // The message channel technique was discovered by Malte Ubl and was the
    // original foundation for this library.
    // http://www.nonblocking.io/2011/06/windownexttick.html
    
    // Safari 6.0.5 (at least) intermittently fails to create message ports on a
    // page's first load. Thankfully, this version of Safari supports
    // MutationObservers, so we don't need to fall back in that case.
    
    // function makeRequestCallFromMessageChannel(callback) {
    //     var channel = new MessageChannel();
    //     channel.port1.onmessage = callback;
    //     return function requestCall() {
    //         channel.port2.postMessage(0);
    //     };
    // }
    
    // For reasons explained above, we are also unable to use `setImmediate`
    // under any circumstances.
    // Even if we were, there is another bug in Internet Explorer 10.
    // It is not sufficient to assign `setImmediate` to `requestFlush` because
    // `setImmediate` must be called *by name* and therefore must be wrapped in a
    // closure.
    // Never forget.
    
    // function makeRequestCallFromSetImmediate(callback) {
    //     return function requestCall() {
    //         setImmediate(callback);
    //     };
    // }
    
    // Safari 6.0 has a problem where timers will get lost while the user is
    // scrolling. This problem does not impact ASAP because Safari 6.0 supports
    // mutation observers, so that implementation is used instead.
    // However, if we ever elect to use timers in Safari, the prevalent work-around
    // is to add a scroll event listener that calls for a flush.
    
    // `setTimeout` does not call the passed callback if the delay is less than
    // approximately 7 in web workers in Firefox 8 through 18, and sometimes not
    // even then.
    
    function makeRequestCallFromTimer(callback) {
        return function requestCall() {
            // We dispatch a timeout with a specified delay of 0 for engines that
            // can reliably accommodate that request. This will usually be snapped
            // to a 4 milisecond delay, but once we're flushing, there's no delay
            // between events.
            var timeoutHandle = setTimeout(handleTimer, 0);
            // However, since this timer gets frequently dropped in Firefox
            // workers, we enlist an interval handle that will try to fire
            // an event 20 times per second until it succeeds.
            var intervalHandle = setInterval(handleTimer, 50);
    
            function handleTimer() {
                // Whichever timer succeeds will cancel both timers and
                // execute the callback.
                clearTimeout(timeoutHandle);
                clearInterval(intervalHandle);
                callback();
            }
        };
    }
    
    // This is for `asap.js` only.
    // Its name will be periodically randomized to break any code that depends on
    // its existence.
    rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;
    
    // ASAP was originally a nextTick shim included in Q. This was factored out
    // into this ASAP package. It was later adapted to RSVP which made further
    // amendments. These decisions, particularly to marginalize MessageChannel and
    // to capture the MutationObserver implementation in a closure, were integrated
    // back into ASAP proper.
    // https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/index.js":
    /*!*************************************!*\
      !*** ./node_modules/axios/index.js ***!
      \*************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    module.exports = __webpack_require__(/*! ./lib/axios */ "./node_modules/axios/lib/axios.js");
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/adapters/xhr.js":
    /*!************************************************!*\
      !*** ./node_modules/axios/lib/adapters/xhr.js ***!
      \************************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
    var settle = __webpack_require__(/*! ./../core/settle */ "./node_modules/axios/lib/core/settle.js");
    var cookies = __webpack_require__(/*! ./../helpers/cookies */ "./node_modules/axios/lib/helpers/cookies.js");
    var buildURL = __webpack_require__(/*! ./../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
    var buildFullPath = __webpack_require__(/*! ../core/buildFullPath */ "./node_modules/axios/lib/core/buildFullPath.js");
    var parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ "./node_modules/axios/lib/helpers/parseHeaders.js");
    var isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ "./node_modules/axios/lib/helpers/isURLSameOrigin.js");
    var createError = __webpack_require__(/*! ../core/createError */ "./node_modules/axios/lib/core/createError.js");
    
    module.exports = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;
        var responseType = config.responseType;
    
        if (utils.isFormData(requestData)) {
          delete requestHeaders['Content-Type']; // Let the browser set it
        }
    
        var request = new XMLHttpRequest();
    
        // HTTP basic authentication
        if (config.auth) {
          var username = config.auth.username || '';
          var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
          requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
        }
    
        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
    
        // Set the request timeout in MS
        request.timeout = config.timeout;
    
        function onloadend() {
          if (!request) {
            return;
          }
          // Prepare the response
          var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?
            request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config: config,
            request: request
          };
    
          settle(resolve, reject, response);
    
          // Clean up request
          request = null;
        }
    
        if ('onloadend' in request) {
          // Use onloadend if available
          request.onloadend = onloadend;
        } else {
          // Listen for ready state to emulate onloadend
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
    
            // The request errored out and we didn't get a response, this will be
            // handled by onerror instead
            // With one exception: request that using file: protocol, most browsers
            // will return status as 0 even though it's a successful request
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
              return;
            }
            // readystate handler is calling before onerror or ontimeout handlers,
            // so we should call onloadend on the next 'tick'
            setTimeout(onloadend);
          };
        }
    
        // Handle browser request cancellation (as opposed to a manual cancellation)
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
    
          reject(createError('Request aborted', config, 'ECONNABORTED', request));
    
          // Clean up request
          request = null;
        };
    
        // Handle low level network errors
        request.onerror = function handleError() {
          // Real errors are hidden from us by the browser
          // onerror should only fire if it's a network error
          reject(createError('Network Error', config, null, request));
    
          // Clean up request
          request = null;
        };
    
        // Handle timeout
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(createError(
            timeoutErrorMessage,
            config,
            config.transitional && config.transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',
            request));
    
          // Clean up request
          request = null;
        };
    
        // Add xsrf header
        // This is only done if running in a standard browser environment.
        // Specifically not if we're in a web worker, or react-native.
        if (utils.isStandardBrowserEnv()) {
          // Add xsrf header
          var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
            cookies.read(config.xsrfCookieName) :
            undefined;
    
          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }
    
        // Add headers to the request
        if ('setRequestHeader' in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
              // Remove Content-Type if data is undefined
              delete requestHeaders[key];
            } else {
              // Otherwise add header to the request
              request.setRequestHeader(key, val);
            }
          });
        }
    
        // Add withCredentials to request if needed
        if (!utils.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
    
        // Add responseType to request if needed
        if (responseType && responseType !== 'json') {
          request.responseType = config.responseType;
        }
    
        // Handle progress if needed
        if (typeof config.onDownloadProgress === 'function') {
          request.addEventListener('progress', config.onDownloadProgress);
        }
    
        // Not all browsers support upload events
        if (typeof config.onUploadProgress === 'function' && request.upload) {
          request.upload.addEventListener('progress', config.onUploadProgress);
        }
    
        if (config.cancelToken) {
          // Handle cancellation
          config.cancelToken.promise.then(function onCanceled(cancel) {
            if (!request) {
              return;
            }
    
            request.abort();
            reject(cancel);
            // Clean up request
            request = null;
          });
        }
    
        if (!requestData) {
          requestData = null;
        }
    
        // Send the request
        request.send(requestData);
      });
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/axios.js":
    /*!*****************************************!*\
      !*** ./node_modules/axios/lib/axios.js ***!
      \*****************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
    var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");
    var Axios = __webpack_require__(/*! ./core/Axios */ "./node_modules/axios/lib/core/Axios.js");
    var mergeConfig = __webpack_require__(/*! ./core/mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");
    var defaults = __webpack_require__(/*! ./defaults */ "./node_modules/axios/lib/defaults.js");
    
    /**
     * Create an instance of Axios
     *
     * @param {Object} defaultConfig The default config for the instance
     * @return {Axios} A new instance of Axios
     */
    function createInstance(defaultConfig) {
      var context = new Axios(defaultConfig);
      var instance = bind(Axios.prototype.request, context);
    
      // Copy axios.prototype to instance
      utils.extend(instance, Axios.prototype, context);
    
      // Copy context to instance
      utils.extend(instance, context);
    
      return instance;
    }
    
    // Create the default instance to be exported
    var axios = createInstance(defaults);
    
    // Expose Axios class to allow class inheritance
    axios.Axios = Axios;
    
    // Factory for creating new instances
    axios.create = function create(instanceConfig) {
      return createInstance(mergeConfig(axios.defaults, instanceConfig));
    };
    
    // Expose Cancel & CancelToken
    axios.Cancel = __webpack_require__(/*! ./cancel/Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");
    axios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ "./node_modules/axios/lib/cancel/CancelToken.js");
    axios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");
    
    // Expose all/spread
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = __webpack_require__(/*! ./helpers/spread */ "./node_modules/axios/lib/helpers/spread.js");
    
    // Expose isAxiosError
    axios.isAxiosError = __webpack_require__(/*! ./helpers/isAxiosError */ "./node_modules/axios/lib/helpers/isAxiosError.js");
    
    module.exports = axios;
    
    // Allow use of default import syntax in TypeScript
    module.exports["default"] = axios;
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/cancel/Cancel.js":
    /*!*************************************************!*\
      !*** ./node_modules/axios/lib/cancel/Cancel.js ***!
      \*************************************************/
    /***/ ((module) => {
    
    "use strict";
    
    
    /**
     * A `Cancel` is an object that is thrown when an operation is canceled.
     *
     * @class
     * @param {string=} message The message.
     */
    function Cancel(message) {
      this.message = message;
    }
    
    Cancel.prototype.toString = function toString() {
      return 'Cancel' + (this.message ? ': ' + this.message : '');
    };
    
    Cancel.prototype.__CANCEL__ = true;
    
    module.exports = Cancel;
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/cancel/CancelToken.js":
    /*!******************************************************!*\
      !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
      \******************************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    var Cancel = __webpack_require__(/*! ./Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");
    
    /**
     * A `CancelToken` is an object that can be used to request cancellation of an operation.
     *
     * @class
     * @param {Function} executor The executor function.
     */
    function CancelToken(executor) {
      if (typeof executor !== 'function') {
        throw new TypeError('executor must be a function.');
      }
    
      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
    
      var token = this;
      executor(function cancel(message) {
        if (token.reason) {
          // Cancellation has already been requested
          return;
        }
    
        token.reason = new Cancel(message);
        resolvePromise(token.reason);
      });
    }
    
    /**
     * Throws a `Cancel` if cancellation has been requested.
     */
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };
    
    /**
     * Returns an object that contains a new `CancelToken` and a function that, when called,
     * cancels the `CancelToken`.
     */
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token: token,
        cancel: cancel
      };
    };
    
    module.exports = CancelToken;
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/cancel/isCancel.js":
    /*!***************************************************!*\
      !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
      \***************************************************/
    /***/ ((module) => {
    
    "use strict";
    
    
    module.exports = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/core/Axios.js":
    /*!**********************************************!*\
      !*** ./node_modules/axios/lib/core/Axios.js ***!
      \**********************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
    var buildURL = __webpack_require__(/*! ../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
    var InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ "./node_modules/axios/lib/core/InterceptorManager.js");
    var dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ "./node_modules/axios/lib/core/dispatchRequest.js");
    var mergeConfig = __webpack_require__(/*! ./mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");
    var validator = __webpack_require__(/*! ../helpers/validator */ "./node_modules/axios/lib/helpers/validator.js");
    
    var validators = validator.validators;
    /**
     * Create a new instance of Axios
     *
     * @param {Object} instanceConfig The default config for the instance
     */
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    
    /**
     * Dispatch a request
     *
     * @param {Object} config The config specific for this request (merged with this.defaults)
     */
    Axios.prototype.request = function request(config) {
      /*eslint no-param-reassign:0*/
      // Allow for axios('example/url'[, config]) a la fetch API
      if (typeof config === 'string') {
        config = arguments[1] || {};
        config.url = arguments[0];
      } else {
        config = config || {};
      }
    
      config = mergeConfig(this.defaults, config);
    
      // Set config.method
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = 'get';
      }
    
      var transitional = config.transitional;
    
      if (transitional !== undefined) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean, '1.0.0'),
          forcedJSONParsing: validators.transitional(validators.boolean, '1.0.0'),
          clarifyTimeoutError: validators.transitional(validators.boolean, '1.0.0')
        }, false);
      }
    
      // filter out skipped interceptors
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
          return;
        }
    
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
    
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
    
      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
    
      var promise;
    
      if (!synchronousRequestInterceptors) {
        var chain = [dispatchRequest, undefined];
    
        Array.prototype.unshift.apply(chain, requestInterceptorChain);
        chain = chain.concat(responseInterceptorChain);
    
        promise = Promise.resolve(config);
        while (chain.length) {
          promise = promise.then(chain.shift(), chain.shift());
        }
    
        return promise;
      }
    
    
      var newConfig = config;
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected(error);
          break;
        }
      }
    
      try {
        promise = dispatchRequest(newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
    
      while (responseInterceptorChain.length) {
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
      }
    
      return promise;
    };
    
    Axios.prototype.getUri = function getUri(config) {
      config = mergeConfig(this.defaults, config);
      return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
    };
    
    // Provide aliases for supported request methods
    utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
      /*eslint func-names:0*/
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method: method,
          url: url,
          data: (config || {}).data
        }));
      };
    });
    
    utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
      /*eslint func-names:0*/
      Axios.prototype[method] = function(url, data, config) {
        return this.request(mergeConfig(config || {}, {
          method: method,
          url: url,
          data: data
        }));
      };
    });
    
    module.exports = Axios;
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/core/InterceptorManager.js":
    /*!***********************************************************!*\
      !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
      \***********************************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
    
    function InterceptorManager() {
      this.handlers = [];
    }
    
    /**
     * Add a new interceptor to the stack
     *
     * @param {Function} fulfilled The function to handle `then` for a `Promise`
     * @param {Function} rejected The function to handle `reject` for a `Promise`
     *
     * @return {Number} An ID used to remove interceptor later
     */
    InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled: fulfilled,
        rejected: rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    };
    
    /**
     * Remove an interceptor from the stack
     *
     * @param {Number} id The ID that was returned by `use`
     */
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };
    
    /**
     * Iterate over all the registered interceptors
     *
     * This method is particularly useful for skipping over any
     * interceptors that may have become `null` calling `eject`.
     *
     * @param {Function} fn The function to call for each interceptor
     */
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };
    
    module.exports = InterceptorManager;
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/core/buildFullPath.js":
    /*!******************************************************!*\
      !*** ./node_modules/axios/lib/core/buildFullPath.js ***!
      \******************************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    var isAbsoluteURL = __webpack_require__(/*! ../helpers/isAbsoluteURL */ "./node_modules/axios/lib/helpers/isAbsoluteURL.js");
    var combineURLs = __webpack_require__(/*! ../helpers/combineURLs */ "./node_modules/axios/lib/helpers/combineURLs.js");
    
    /**
     * Creates a new URL by combining the baseURL with the requestedURL,
     * only when the requestedURL is not already an absolute URL.
     * If the requestURL is absolute, this function returns the requestedURL untouched.
     *
     * @param {string} baseURL The base URL
     * @param {string} requestedURL Absolute or relative URL to combine
     * @returns {string} The combined full path
     */
    module.exports = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/core/createError.js":
    /*!****************************************************!*\
      !*** ./node_modules/axios/lib/core/createError.js ***!
      \****************************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    var enhanceError = __webpack_require__(/*! ./enhanceError */ "./node_modules/axios/lib/core/enhanceError.js");
    
    /**
     * Create an Error with the specified message, config, error code, request and response.
     *
     * @param {string} message The error message.
     * @param {Object} config The config.
     * @param {string} [code] The error code (for example, 'ECONNABORTED').
     * @param {Object} [request] The request.
     * @param {Object} [response] The response.
     * @returns {Error} The created error.
     */
    module.exports = function createError(message, config, code, request, response) {
      var error = new Error(message);
      return enhanceError(error, config, code, request, response);
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/core/dispatchRequest.js":
    /*!********************************************************!*\
      !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
      \********************************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
    var transformData = __webpack_require__(/*! ./transformData */ "./node_modules/axios/lib/core/transformData.js");
    var isCancel = __webpack_require__(/*! ../cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");
    var defaults = __webpack_require__(/*! ../defaults */ "./node_modules/axios/lib/defaults.js");
    
    /**
     * Throws a `Cancel` if cancellation has been requested.
     */
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
    }
    
    /**
     * Dispatch a request to the server using the configured adapter.
     *
     * @param {object} config The config that is to be used for the request
     * @returns {Promise} The Promise to be fulfilled
     */
    module.exports = function dispatchRequest(config) {
      throwIfCancellationRequested(config);
    
      // Ensure headers exist
      config.headers = config.headers || {};
    
      // Transform request data
      config.data = transformData.call(
        config,
        config.data,
        config.headers,
        config.transformRequest
      );
    
      // Flatten headers
      config.headers = utils.merge(
        config.headers.common || {},
        config.headers[config.method] || {},
        config.headers
      );
    
      utils.forEach(
        ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
        function cleanHeaderConfig(method) {
          delete config.headers[method];
        }
      );
    
      var adapter = config.adapter || defaults.adapter;
    
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
    
        // Transform response data
        response.data = transformData.call(
          config,
          response.data,
          response.headers,
          config.transformResponse
        );
    
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
    
          // Transform response data
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              reason.response.data,
              reason.response.headers,
              config.transformResponse
            );
          }
        }
    
        return Promise.reject(reason);
      });
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/core/enhanceError.js":
    /*!*****************************************************!*\
      !*** ./node_modules/axios/lib/core/enhanceError.js ***!
      \*****************************************************/
    /***/ ((module) => {
    
    "use strict";
    
    
    /**
     * Update an Error with the specified config, error code, and response.
     *
     * @param {Error} error The error to update.
     * @param {Object} config The config.
     * @param {string} [code] The error code (for example, 'ECONNABORTED').
     * @param {Object} [request] The request.
     * @param {Object} [response] The response.
     * @returns {Error} The error.
     */
    module.exports = function enhanceError(error, config, code, request, response) {
      error.config = config;
      if (code) {
        error.code = code;
      }
    
      error.request = request;
      error.response = response;
      error.isAxiosError = true;
    
      error.toJSON = function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: this.config,
          code: this.code
        };
      };
      return error;
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/core/mergeConfig.js":
    /*!****************************************************!*\
      !*** ./node_modules/axios/lib/core/mergeConfig.js ***!
      \****************************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");
    
    /**
     * Config-specific merge-function which creates a new config-object
     * by merging two configuration objects together.
     *
     * @param {Object} config1
     * @param {Object} config2
     * @returns {Object} New object resulting from merging config2 to config1
     */
    module.exports = function mergeConfig(config1, config2) {
      // eslint-disable-next-line no-param-reassign
      config2 = config2 || {};
      var config = {};
    
      var valueFromConfig2Keys = ['url', 'method', 'data'];
      var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
      var defaultToConfig2Keys = [
        'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',
        'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
        'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',
        'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',
        'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'
      ];
      var directMergeKeys = ['validateStatus'];
    
      function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }
    
      function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(config1[prop], config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          config[prop] = getMergedValue(undefined, config1[prop]);
        }
      }
    
      utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(undefined, config2[prop]);
        }
      });
    
      utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
    
      utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(undefined, config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          config[prop] = getMergedValue(undefined, config1[prop]);
        }
      });
    
      utils.forEach(directMergeKeys, function merge(prop) {
        if (prop in config2) {
          config[prop] = getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          config[prop] = getMergedValue(undefined, config1[prop]);
        }
      });
    
      var axiosKeys = valueFromConfig2Keys
        .concat(mergeDeepPropertiesKeys)
        .concat(defaultToConfig2Keys)
        .concat(directMergeKeys);
    
      var otherKeys = Object
        .keys(config1)
        .concat(Object.keys(config2))
        .filter(function filterAxiosKeys(key) {
          return axiosKeys.indexOf(key) === -1;
        });
    
      utils.forEach(otherKeys, mergeDeepProperties);
    
      return config;
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/core/settle.js":
    /*!***********************************************!*\
      !*** ./node_modules/axios/lib/core/settle.js ***!
      \***********************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    var createError = __webpack_require__(/*! ./createError */ "./node_modules/axios/lib/core/createError.js");
    
    /**
     * Resolve or reject a Promise based on response status.
     *
     * @param {Function} resolve A function that resolves the promise.
     * @param {Function} reject A function that rejects the promise.
     * @param {object} response The response.
     */
    module.exports = function settle(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(createError(
          'Request failed with status code ' + response.status,
          response.config,
          null,
          response.request,
          response
        ));
      }
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/core/transformData.js":
    /*!******************************************************!*\
      !*** ./node_modules/axios/lib/core/transformData.js ***!
      \******************************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
    var defaults = __webpack_require__(/*! ./../defaults */ "./node_modules/axios/lib/defaults.js");
    
    /**
     * Transform the data for a request or a response
     *
     * @param {Object|String} data The data to be transformed
     * @param {Array} headers The headers for the request or response
     * @param {Array|Function} fns A single function or Array of functions
     * @returns {*} The resulting transformed data
     */
    module.exports = function transformData(data, headers, fns) {
      var context = this || defaults;
      /*eslint no-param-reassign:0*/
      utils.forEach(fns, function transform(fn) {
        data = fn.call(context, data, headers);
      });
    
      return data;
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/defaults.js":
    /*!********************************************!*\
      !*** ./node_modules/axios/lib/defaults.js ***!
      \********************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
    var normalizeHeaderName = __webpack_require__(/*! ./helpers/normalizeHeaderName */ "./node_modules/axios/lib/helpers/normalizeHeaderName.js");
    var enhanceError = __webpack_require__(/*! ./core/enhanceError */ "./node_modules/axios/lib/core/enhanceError.js");
    
    var DEFAULT_CONTENT_TYPE = {
      'Content-Type': 'application/x-www-form-urlencoded'
    };
    
    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
        headers['Content-Type'] = value;
      }
    }
    
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== 'undefined') {
        // For browsers use XHR adapter
        adapter = __webpack_require__(/*! ./adapters/xhr */ "./node_modules/axios/lib/adapters/xhr.js");
      } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
        // For node use HTTP adapter
        adapter = __webpack_require__(/*! ./adapters/http */ "./node_modules/axios/lib/adapters/xhr.js");
      }
      return adapter;
    }
    
    function stringifySafely(rawValue, parser, encoder) {
      if (utils.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils.trim(rawValue);
        } catch (e) {
          if (e.name !== 'SyntaxError') {
            throw e;
          }
        }
      }
    
      return (encoder || JSON.stringify)(rawValue);
    }
    
    var defaults = {
    
      transitional: {
        silentJSONParsing: true,
        forcedJSONParsing: true,
        clarifyTimeoutError: false
      },
    
      adapter: getDefaultAdapter(),
    
      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, 'Accept');
        normalizeHeaderName(headers, 'Content-Type');
    
        if (utils.isFormData(data) ||
          utils.isArrayBuffer(data) ||
          utils.isBuffer(data) ||
          utils.isStream(data) ||
          utils.isFile(data) ||
          utils.isBlob(data)
        ) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
          return data.toString();
        }
        if (utils.isObject(data) || (headers && headers['Content-Type'] === 'application/json')) {
          setContentTypeIfUnset(headers, 'application/json');
          return stringifySafely(data);
        }
        return data;
      }],
    
      transformResponse: [function transformResponse(data) {
        var transitional = this.transitional;
        var silentJSONParsing = transitional && transitional.silentJSONParsing;
        var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';
    
        if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === 'SyntaxError') {
                throw enhanceError(e, this, 'E_JSON_PARSE');
              }
              throw e;
            }
          }
        }
    
        return data;
      }],
    
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
    
      xsrfCookieName: 'XSRF-TOKEN',
      xsrfHeaderName: 'X-XSRF-TOKEN',
    
      maxContentLength: -1,
      maxBodyLength: -1,
    
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      }
    };
    
    defaults.headers = {
      common: {
        'Accept': 'application/json, text/plain, */*'
      }
    };
    
    utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });
    
    utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });
    
    module.exports = defaults;
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/helpers/bind.js":
    /*!************************************************!*\
      !*** ./node_modules/axios/lib/helpers/bind.js ***!
      \************************************************/
    /***/ ((module) => {
    
    "use strict";
    
    
    module.exports = function bind(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/helpers/buildURL.js":
    /*!****************************************************!*\
      !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
      \****************************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
    
    function encode(val) {
      return encodeURIComponent(val).
        replace(/%3A/gi, ':').
        replace(/%24/g, '$').
        replace(/%2C/gi, ',').
        replace(/%20/g, '+').
        replace(/%5B/gi, '[').
        replace(/%5D/gi, ']');
    }
    
    /**
     * Build a URL by appending params to the end
     *
     * @param {string} url The base of the url (e.g., http://www.google.com)
     * @param {object} [params] The params to be appended
     * @returns {string} The formatted url
     */
    module.exports = function buildURL(url, params, paramsSerializer) {
      /*eslint no-param-reassign:0*/
      if (!params) {
        return url;
      }
    
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
    
        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === 'undefined') {
            return;
          }
    
          if (utils.isArray(val)) {
            key = key + '[]';
          } else {
            val = [val];
          }
    
          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + '=' + encode(v));
          });
        });
    
        serializedParams = parts.join('&');
      }
    
      if (serializedParams) {
        var hashmarkIndex = url.indexOf('#');
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
    
        url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
      }
    
      return url;
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/helpers/combineURLs.js":
    /*!*******************************************************!*\
      !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
      \*******************************************************/
    /***/ ((module) => {
    
    "use strict";
    
    
    /**
     * Creates a new URL by combining the specified URLs
     *
     * @param {string} baseURL The base URL
     * @param {string} relativeURL The relative URL
     * @returns {string} The combined URL
     */
    module.exports = function combineURLs(baseURL, relativeURL) {
      return relativeURL
        ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
        : baseURL;
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/helpers/cookies.js":
    /*!***************************************************!*\
      !*** ./node_modules/axios/lib/helpers/cookies.js ***!
      \***************************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
    
    module.exports = (
      utils.isStandardBrowserEnv() ?
    
      // Standard browser envs support document.cookie
        (function standardBrowserEnv() {
          return {
            write: function write(name, value, expires, path, domain, secure) {
              var cookie = [];
              cookie.push(name + '=' + encodeURIComponent(value));
    
              if (utils.isNumber(expires)) {
                cookie.push('expires=' + new Date(expires).toGMTString());
              }
    
              if (utils.isString(path)) {
                cookie.push('path=' + path);
              }
    
              if (utils.isString(domain)) {
                cookie.push('domain=' + domain);
              }
    
              if (secure === true) {
                cookie.push('secure');
              }
    
              document.cookie = cookie.join('; ');
            },
    
            read: function read(name) {
              var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
              return (match ? decodeURIComponent(match[3]) : null);
            },
    
            remove: function remove(name) {
              this.write(name, '', Date.now() - 86400000);
            }
          };
        })() :
    
      // Non standard browser env (web workers, react-native) lack needed support.
        (function nonStandardBrowserEnv() {
          return {
            write: function write() {},
            read: function read() { return null; },
            remove: function remove() {}
          };
        })()
    );
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/helpers/isAbsoluteURL.js":
    /*!*********************************************************!*\
      !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
      \*********************************************************/
    /***/ ((module) => {
    
    "use strict";
    
    
    /**
     * Determines whether the specified URL is absolute
     *
     * @param {string} url The URL to test
     * @returns {boolean} True if the specified URL is absolute, otherwise false
     */
    module.exports = function isAbsoluteURL(url) {
      // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
      // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
      // by any combination of letters, digits, plus, period, or hyphen.
      return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/helpers/isAxiosError.js":
    /*!********************************************************!*\
      !*** ./node_modules/axios/lib/helpers/isAxiosError.js ***!
      \********************************************************/
    /***/ ((module) => {
    
    "use strict";
    
    
    /**
     * Determines whether the payload is an error thrown by Axios
     *
     * @param {*} payload The value to test
     * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
     */
    module.exports = function isAxiosError(payload) {
      return (typeof payload === 'object') && (payload.isAxiosError === true);
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/helpers/isURLSameOrigin.js":
    /*!***********************************************************!*\
      !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
      \***********************************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
    
    module.exports = (
      utils.isStandardBrowserEnv() ?
    
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
        (function standardBrowserEnv() {
          var msie = /(msie|trident)/i.test(navigator.userAgent);
          var urlParsingNode = document.createElement('a');
          var originURL;
    
          /**
        * Parse a URL to discover it's components
        *
        * @param {String} url The URL to be parsed
        * @returns {Object}
        */
          function resolveURL(url) {
            var href = url;
    
            if (msie) {
            // IE needs attribute set twice to normalize properties
              urlParsingNode.setAttribute('href', href);
              href = urlParsingNode.href;
            }
    
            urlParsingNode.setAttribute('href', href);
    
            // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
            return {
              href: urlParsingNode.href,
              protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
              host: urlParsingNode.host,
              search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
              hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
              hostname: urlParsingNode.hostname,
              port: urlParsingNode.port,
              pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
                urlParsingNode.pathname :
                '/' + urlParsingNode.pathname
            };
          }
    
          originURL = resolveURL(window.location.href);
    
          /**
        * Determine if a URL shares the same origin as the current location
        *
        * @param {String} requestURL The URL to test
        * @returns {boolean} True if URL shares the same origin, otherwise false
        */
          return function isURLSameOrigin(requestURL) {
            var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
            return (parsed.protocol === originURL.protocol &&
                parsed.host === originURL.host);
          };
        })() :
    
      // Non standard browser envs (web workers, react-native) lack needed support.
        (function nonStandardBrowserEnv() {
          return function isURLSameOrigin() {
            return true;
          };
        })()
    );
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/helpers/normalizeHeaderName.js":
    /*!***************************************************************!*\
      !*** ./node_modules/axios/lib/helpers/normalizeHeaderName.js ***!
      \***************************************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");
    
    module.exports = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/helpers/parseHeaders.js":
    /*!********************************************************!*\
      !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
      \********************************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
    
    // Headers whose duplicates are ignored by node
    // c.f. https://nodejs.org/api/http.html#http_message_headers
    var ignoreDuplicateOf = [
      'age', 'authorization', 'content-length', 'content-type', 'etag',
      'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
      'last-modified', 'location', 'max-forwards', 'proxy-authorization',
      'referer', 'retry-after', 'user-agent'
    ];
    
    /**
     * Parse headers into an object
     *
     * ```
     * Date: Wed, 27 Aug 2014 08:58:49 GMT
     * Content-Type: application/json
     * Connection: keep-alive
     * Transfer-Encoding: chunked
     * ```
     *
     * @param {String} headers Headers needing to be parsed
     * @returns {Object} Headers parsed into an object
     */
    module.exports = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;
    
      if (!headers) { return parsed; }
    
      utils.forEach(headers.split('\n'), function parser(line) {
        i = line.indexOf(':');
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));
    
        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === 'set-cookie') {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
          }
        }
      });
    
      return parsed;
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/helpers/spread.js":
    /*!**************************************************!*\
      !*** ./node_modules/axios/lib/helpers/spread.js ***!
      \**************************************************/
    /***/ ((module) => {
    
    "use strict";
    
    
    /**
     * Syntactic sugar for invoking a function and expanding an array for arguments.
     *
     * Common use case would be to use `Function.prototype.apply`.
     *
     *  ```js
     *  function f(x, y, z) {}
     *  var args = [1, 2, 3];
     *  f.apply(null, args);
     *  ```
     *
     * With `spread` this example can be re-written.
     *
     *  ```js
     *  spread(function(x, y, z) {})([1, 2, 3]);
     *  ```
     *
     * @param {Function} callback
     * @returns {Function}
     */
    module.exports = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/helpers/validator.js":
    /*!*****************************************************!*\
      !*** ./node_modules/axios/lib/helpers/validator.js ***!
      \*****************************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    var pkg = __webpack_require__(/*! ./../../package.json */ "./node_modules/axios/package.json");
    
    var validators = {};
    
    // eslint-disable-next-line func-names
    ['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {
      validators[type] = function validator(thing) {
        return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
      };
    });
    
    var deprecatedWarnings = {};
    var currentVerArr = pkg.version.split('.');
    
    /**
     * Compare package versions
     * @param {string} version
     * @param {string?} thanVersion
     * @returns {boolean}
     */
    function isOlderVersion(version, thanVersion) {
      var pkgVersionArr = thanVersion ? thanVersion.split('.') : currentVerArr;
      var destVer = version.split('.');
      for (var i = 0; i < 3; i++) {
        if (pkgVersionArr[i] > destVer[i]) {
          return true;
        } else if (pkgVersionArr[i] < destVer[i]) {
          return false;
        }
      }
      return false;
    }
    
    /**
     * Transitional option validator
     * @param {function|boolean?} validator
     * @param {string?} version
     * @param {string} message
     * @returns {function}
     */
    validators.transitional = function transitional(validator, version, message) {
      var isDeprecated = version && isOlderVersion(version);
    
      function formatMessage(opt, desc) {
        return '[Axios v' + pkg.version + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
      }
    
      // eslint-disable-next-line func-names
      return function(value, opt, opts) {
        if (validator === false) {
          throw new Error(formatMessage(opt, ' has been removed in ' + version));
        }
    
        if (isDeprecated && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          // eslint-disable-next-line no-console
          console.warn(
            formatMessage(
              opt,
              ' has been deprecated since v' + version + ' and will be removed in the near future'
            )
          );
        }
    
        return validator ? validator(value, opt, opts) : true;
      };
    };
    
    /**
     * Assert object's properties type
     * @param {object} options
     * @param {object} schema
     * @param {boolean?} allowUnknown
     */
    
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== 'object') {
        throw new TypeError('options must be an object');
      }
      var keys = Object.keys(options);
      var i = keys.length;
      while (i-- > 0) {
        var opt = keys[i];
        var validator = schema[opt];
        if (validator) {
          var value = options[opt];
          var result = value === undefined || validator(value, opt, options);
          if (result !== true) {
            throw new TypeError('option ' + opt + ' must be ' + result);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw Error('Unknown option ' + opt);
        }
      }
    }
    
    module.exports = {
      isOlderVersion: isOlderVersion,
      assertOptions: assertOptions,
      validators: validators
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/utils.js":
    /*!*****************************************!*\
      !*** ./node_modules/axios/lib/utils.js ***!
      \*****************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");
    
    // utils is a library of generic helper functions non-specific to axios
    
    var toString = Object.prototype.toString;
    
    /**
     * Determine if a value is an Array
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an Array, otherwise false
     */
    function isArray(val) {
      return toString.call(val) === '[object Array]';
    }
    
    /**
     * Determine if a value is undefined
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if the value is undefined, otherwise false
     */
    function isUndefined(val) {
      return typeof val === 'undefined';
    }
    
    /**
     * Determine if a value is a Buffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Buffer, otherwise false
     */
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
        && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
    }
    
    /**
     * Determine if a value is an ArrayBuffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an ArrayBuffer, otherwise false
     */
    function isArrayBuffer(val) {
      return toString.call(val) === '[object ArrayBuffer]';
    }
    
    /**
     * Determine if a value is a FormData
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an FormData, otherwise false
     */
    function isFormData(val) {
      return (typeof FormData !== 'undefined') && (val instanceof FormData);
    }
    
    /**
     * Determine if a value is a view on an ArrayBuffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
     */
    function isArrayBufferView(val) {
      var result;
      if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
        result = ArrayBuffer.isView(val);
      } else {
        result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
      }
      return result;
    }
    
    /**
     * Determine if a value is a String
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a String, otherwise false
     */
    function isString(val) {
      return typeof val === 'string';
    }
    
    /**
     * Determine if a value is a Number
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Number, otherwise false
     */
    function isNumber(val) {
      return typeof val === 'number';
    }
    
    /**
     * Determine if a value is an Object
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an Object, otherwise false
     */
    function isObject(val) {
      return val !== null && typeof val === 'object';
    }
    
    /**
     * Determine if a value is a plain Object
     *
     * @param {Object} val The value to test
     * @return {boolean} True if value is a plain Object, otherwise false
     */
    function isPlainObject(val) {
      if (toString.call(val) !== '[object Object]') {
        return false;
      }
    
      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }
    
    /**
     * Determine if a value is a Date
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Date, otherwise false
     */
    function isDate(val) {
      return toString.call(val) === '[object Date]';
    }
    
    /**
     * Determine if a value is a File
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a File, otherwise false
     */
    function isFile(val) {
      return toString.call(val) === '[object File]';
    }
    
    /**
     * Determine if a value is a Blob
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Blob, otherwise false
     */
    function isBlob(val) {
      return toString.call(val) === '[object Blob]';
    }
    
    /**
     * Determine if a value is a Function
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Function, otherwise false
     */
    function isFunction(val) {
      return toString.call(val) === '[object Function]';
    }
    
    /**
     * Determine if a value is a Stream
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Stream, otherwise false
     */
    function isStream(val) {
      return isObject(val) && isFunction(val.pipe);
    }
    
    /**
     * Determine if a value is a URLSearchParams object
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a URLSearchParams object, otherwise false
     */
    function isURLSearchParams(val) {
      return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
    }
    
    /**
     * Trim excess whitespace off the beginning and end of a string
     *
     * @param {String} str The String to trim
     * @returns {String} The String freed of excess whitespace
     */
    function trim(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
    }
    
    /**
     * Determine if we're running in a standard browser environment
     *
     * This allows axios to run in a web worker, and react-native.
     * Both environments support XMLHttpRequest, but not fully standard globals.
     *
     * web workers:
     *  typeof window -> undefined
     *  typeof document -> undefined
     *
     * react-native:
     *  navigator.product -> 'ReactNative'
     * nativescript
     *  navigator.product -> 'NativeScript' or 'NS'
     */
    function isStandardBrowserEnv() {
      if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                               navigator.product === 'NativeScript' ||
                                               navigator.product === 'NS')) {
        return false;
      }
      return (
        typeof window !== 'undefined' &&
        typeof document !== 'undefined'
      );
    }
    
    /**
     * Iterate over an Array or an Object invoking a function for each item.
     *
     * If `obj` is an Array callback will be called passing
     * the value, index, and complete array for each item.
     *
     * If 'obj' is an Object callback will be called passing
     * the value, key, and complete object for each property.
     *
     * @param {Object|Array} obj The object to iterate
     * @param {Function} fn The callback to invoke for each item
     */
    function forEach(obj, fn) {
      // Don't bother if no value provided
      if (obj === null || typeof obj === 'undefined') {
        return;
      }
    
      // Force an array if not already something iterable
      if (typeof obj !== 'object') {
        /*eslint no-param-reassign:0*/
        obj = [obj];
      }
    
      if (isArray(obj)) {
        // Iterate over array values
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        // Iterate over object keys
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    
    /**
     * Accepts varargs expecting each argument to be an object, then
     * immutably merges the properties of each object and returns result.
     *
     * When multiple objects contain the same key the later object in
     * the arguments list will take precedence.
     *
     * Example:
     *
     * ```js
     * var result = merge({foo: 123}, {foo: 456});
     * console.log(result.foo); // outputs 456
     * ```
     *
     * @param {Object} obj1 Object to merge
     * @returns {Object} Result of all merge properties
     */
    function merge(/* obj1, obj2, obj3, ... */) {
      var result = {};
      function assignValue(val, key) {
        if (isPlainObject(result[key]) && isPlainObject(val)) {
          result[key] = merge(result[key], val);
        } else if (isPlainObject(val)) {
          result[key] = merge({}, val);
        } else if (isArray(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }
    
      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }
    
    /**
     * Extends object a by mutably adding to it the properties of object b.
     *
     * @param {Object} a The object to be extended
     * @param {Object} b The object to copy properties from
     * @param {Object} thisArg The object to bind function to
     * @return {Object} The resulting value of object a
     */
    function extend(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === 'function') {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }
    
    /**
     * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
     *
     * @param {string} content with BOM
     * @return {string} content value without BOM
     */
    function stripBOM(content) {
      if (content.charCodeAt(0) === 0xFEFF) {
        content = content.slice(1);
      }
      return content;
    }
    
    module.exports = {
      isArray: isArray,
      isArrayBuffer: isArrayBuffer,
      isBuffer: isBuffer,
      isFormData: isFormData,
      isArrayBufferView: isArrayBufferView,
      isString: isString,
      isNumber: isNumber,
      isObject: isObject,
      isPlainObject: isPlainObject,
      isUndefined: isUndefined,
      isDate: isDate,
      isFile: isFile,
      isBlob: isBlob,
      isFunction: isFunction,
      isStream: isStream,
      isURLSearchParams: isURLSearchParams,
      isStandardBrowserEnv: isStandardBrowserEnv,
      forEach: forEach,
      merge: merge,
      extend: extend,
      trim: trim,
      stripBOM: stripBOM
    };
    
    
    /***/ }),
    
    /***/ "./src/js/modules/graph.js":
    /*!*********************************!*\
      !*** ./src/js/modules/graph.js ***!
      \*********************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
    /* harmony export */ });
    const graph = ref => {
      // setInterval(() => window.location.reload(), 500000);
      console.log(ref);
      console.log('ax');
      const axios = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
      let an = [];
      let response = null;
      let response2 = null;
      new Promise(async (resolve, reject) => {
        try {
          response = await axios.get(`https://api.coincap.io/v2/assets/bitcoin/history?interval=m1`, {
            headers: {
              'Authorization': 'Bearer 96261b71-fe69-46f5-9c5c-c456e1379d8d'
            }
          });
          response2 = await axios.get('https://api.coincap.io/v2/assets/bitcoin', {
            headers: {
              'Authorization': 'Bearer 96261b71-fe69-46f5-9c5c-c456e1379d8d'
            }
          });
        } catch (ex) {
          response = null;
          console.log(ex);
          reject(ex);
        }
        if (response) {
          console.log('do5');
          const json = response.data;
          const json2 = response.data;
          let an = [];
          if (an) {
            let an = [];
          }
          resolve(an);
          resolve(json2);
        }
      }).then(an => {
        const weight = [an[59], an[58], an[57], an[56], an[55], an[54], an[53], an[52], an[51], an[50], an[49], an[48], an[47], an[46], an[45], an[44], an[43], an[42], an[41], an[40], an[39], an[38], an[37], an[36], an[35], an[34], an[33], an[32], an[31], an[30], an[29], an[28], an[27], an[26], an[25], an[24], an[23], an[22], an[21], an[20], an[19], an[18], an[17], an[16], an[15], an[14], an[13], an[12], an[11], an[10], an[9], an[8], an[7], an[6], an[5], an[4], an[3], an[2], an[1], an[0]];
        // const weight = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        const labels = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];
        console.log('do4');
        const ctx = document.getElementById("chart").getContext("2d");
        console.log('do1');
        const options = {};
        $(document).ready(function () {
          Chart.defaults.plugins.legend.display = false;
          Chart.defaults.plugins.tooltipItem = 'yLabel';
          console.log('do2');
          window.myLine = new Chart(ctx, options);
        });
        console.log('end');
      });
    };
    // const datatot = []
    // const arr = [1, 2, 3]
    // const axios = require('axios');
    // let response = null;
    // async function to() {
    //   const main = (arg) => {
    //     const al = new Promise(async (resolve, reject) => {
    //       try {
    //           response = await axios.get('https://api.coincap.io/v2/assets/bitcoin/history?interval=m1', {
    //             headers: {
    //               'Authorization': 'Bearer 96261b71-fe69-46f5-9c5c-c456e1379d8d',
    //             },
    //           });
    //       } catch(ex) {
    //           response = null;
    //           console.log(ex);
    //           reject(ex);
    //       }
    //       if (response) {
    //           // success
    //           const json = response.data;
    //           datatot.push(parseFloat(json['data'][json['data'].length - arg]['priceUsd']))
    //           // const resp = Object.values(json)[1];
    //           // const resp2 = resp[5]['quote']['USD']['price'];
    //           console.log(json['data'][json['data'].length - arg]['priceUsd'])
    //           console.log(datatot)
    //           // console.log(resp);
    //           // console.log(resp2);
    //           resolve(json);
    //           return datatot
    //       }
    //     });
    //   }
    //   main(1)
    //   main(2)
    //   main(3)
    //   main(4)
    //   main(5)
    //   main(6)
    //   main(7)
    //   main(8)
    //   main(9)
    //   main(10)
    // }
    
    // const gr = () => {
    //   console.log('st')
    //   to().then(() => {
    //     console.log(datatot)
    //     datatot.forEach(element => {
    //       console.log(element)
    //     });
    
    //   })
    // }
    /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (graph);
    
    /***/ }),
    
    /***/ "./src/js/modules/graphinfo.js":
    /*!*************************************!*\
      !*** ./src/js/modules/graphinfo.js ***!
      \*************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
    /* harmony export */ });
    const informa = () => {
      const gr = [];
      let i = 6;
      const tt = [];
      const axios = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
      let response3 = null;
      new Promise(async (resolve, reject) => {
        let src3 = "https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1m";
        try {
          response3 = await axios.get(src3, {});
        } catch (ex) {
          response3 = null;
          console.log(ex);
          reject(ex);
        }
        if (response3) {
          console.log('connection...');
          console.log('Sucs...');
          console.log('Already :)');
          while (i < 40 & i > 0) {
            console.log(gr);
            gr.push(Number(response3.data[response3.data.length - i][4]));
            i--;
            console.log(gr[gr.length - 1]);
            tt.push(gr[gr.length - 1]);
          }
          resolve(gr);
        }
      }).then(gr => {
        console.log(gr);
      });
      console.log(gr);
      return t;
    };
    /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (informa);
    
    /***/ }),
    
    /***/ "./src/js/modules/newgraph.js":
    /*!************************************!*\
      !*** ./src/js/modules/newgraph.js ***!
      \************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
    /* harmony export */ });
    /* harmony import */ var promise__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! promise */ "./node_modules/promise/index.js");
    /* harmony import */ var promise__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(promise__WEBPACK_IMPORTED_MODULE_0__);
    /* harmony import */ var _graphinfo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./graphinfo */ "./src/js/modules/graphinfo.js");
    /* harmony import */ var _updation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./updation */ "./src/js/modules/updation.js");
    
    
    
    const gra = () => {
      function grat(ctx) {
        const labels = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];
        const data = [];
        console.log(data);
        const colors = {
          purple: {
            default: "rgba(54, 216, 142, 1)",
            half: "rgba(54, 216, 142, 0.5)",
            quarter: "rgba(54, 216, 142, 0.25)",
            zero: "rgba(54, 216, 142, 0)"
          },
          indigo: {
            default: "rgba(80, 102, 120, 1)",
            quarter: "rgba(80, 102, 120, 0.25)"
          }
        };
        var gradient = ctx.createLinearGradient(0, 25, 0, 300);
        gradient.addColorStop(0, colors.purple.half);
        gradient.addColorStop(0.35, colors.purple.quarter);
        gradient.addColorStop(1, colors.purple.zero);
        const myChart = new Chart(ctx, {
          type: "line",
          data: {
            labels: labels,
            datasets: [{
              fill: true,
              backgroundColor: gradient,
              borderColor: colors.purple.default,
              data: data,
              lineTension: 0.1,
              label: 'course',
              pointBackgroundColor: 'rgba(54, 216, 142, 1)'
            }]
          },
          options: {
            esponsive: true,
            // Автоматическая адаптация к размерам контейнера
            maintainAspectRatio: false,
            // График меняет высоту без изменения пропорций
            animation: false,
            layout: {
              padding: 10
            },
            responsive: true,
            legend: {
              display: false
            },
            scales: {
              y: {
                position: 'right',
                display: 'none'
              },
              xAxes: [{
                gridLines: {
                  display: false,
                  color: 'white'
                },
                ticks: {
                  padding: 10,
                  autoSkip: false
                }
              }],
              yAxes: [{
                scaleLabel: {
                  position: 'right',
                  display: true,
                  padding: 10
                },
                gridLines: {
                  position: 'right',
                  display: true,
                  color: colors.indigo.quarter
                },
                ticks: {
                  beginAtZero: false,
                  padding: 10
                }
              }]
            }
          }
        });
        setInterval(function () {
          new Promise(async (resolve, reject) => {
            let response3 = null;
            const gr = [];
            let i = 55;
            const axios = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
            let src3 = "https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1m";
            try {
              response3 = await axios.get(src3, {});
            } catch (ex) {
              response3 = null;
              console.log(ex);
              reject(ex);
            }
            if (response3) {
              console.log('connection...');
              console.log('Sucs...');
              console.log('Already :)');
              while (i < 101 & i > 0) {
                console.log(gr);
                gr.push(Number(response3.data[response3.data.length - i][4]));
                i--;
                console.log(gr[gr.length - 1]);
              }
              resolve(gr);
            }
          }).then(gr => {
            console.log(gr);
            myChart.data.datasets[0].data = gr;
            myChart.data.datasets[0].data.forEach(element => {
              console.log(element);
            });
            console.log(myChart.data.datasets[0].data);
            myChart.update();
          });
        }, 1000);
      }
      const canvas = document.getElementById('chart');
      const ctx = canvas.getContext('2d');
      grat(ctx);
    };
    /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (gra);
    
    /***/ }),
    
    /***/ "./src/js/modules/pr.js":
    /*!******************************!*\
      !*** ./src/js/modules/pr.js ***!
      \******************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
    /* harmony export */ });
    const pr = () => {
      console.log('cik');
      let price = [];
      let perc = [];
      const axios = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
      let response = null;
      new Promise(async (resolve, reject) => {
        try {
          response = await axios.get('https://api.coincap.io/v2/assets/bitcoin', {
            headers: {
              'Authorization': 'Bearer 96261b71-fe69-46f5-9c5c-c456e1379d8d'
            }
          });
        } catch (ex) {
          response = null;
          console.log(ex);
          reject(ex);
        }
        if (response) {
          const json = response.data;
          console.log(json['data']['priceUsd']);
          console.log(json['data']['changePercent24Hr']);
          price.push(json['data']['priceUsd']);
          perc.push(json['data']['changePercent24Hr']);
          resolve(price);
        }
      }).then(an => {
        const BigPr = document.getElementById('wh');
        const BigPerc = document.getElementById('gr');
        BigPr.textContent = parseInt(price * 100) / 100;
        if (perc < 0) {
          BigPerc.className = 'red';
        } else {
          BigPerc.className = 'gr';
        }
        BigPerc.textContent = parseInt(perc * 100) / 100 + '%';
      });
    };
    /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (pr);
    
    /***/ }),
    
    /***/ "./src/js/modules/sl.js":
    /*!******************************!*\
      !*** ./src/js/modules/sl.js ***!
      \******************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
    /* harmony export */ });
    const sl = () => {
      console.log('sl');
      const a = document.getElementById('oh');
      const b = document.getElementById('fourhour');
      const c = document.getElementById('six');
      const d = document.getElementById('twelehour');
      const e = document.getElementById('day');
      const f = document.getElementById('week');
      console.log(a);
      let response = null;
      const axios = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
      a.addEventListener('click', function () {
        new Promise(async (resolve, reject) => {
          try {
            response = await axios.get(`https://api.coincap.io/v2/assets/bitcoin/history?interval=h1`, {
              headers: {
                'Authorization': 'Bearer 96261b71-fe69-46f5-9c5c-c456e1379d8d'
              }
            });
          } catch (ex) {
            console.log('ERROR');
          }
          if (response) {
            console.log('connection...');
            console.log('Sucs...');
            console.log('Already :)');
            const json = response.data;
            resolve(json);
          }
        }).then(json => {
          console.log('One hour');
          console.log(json);
          console.log('ALL');
        });
      });
      b.addEventListener('click', function () {
        new Promise(async (resolve, reject) => {
          try {
            response = await axios.get(`https://api.coincap.io/v2/assets/bitcoin/history?interval=h4`, {
              headers: {
                'Authorization': 'Bearer 96261b71-fe69-46f5-9c5c-c456e1379d8d'
              }
            });
          } catch (ex) {
            console.log('ERROR');
          }
          if (response) {
            console.log('connection...');
            console.log('Sucs...');
            console.log('Already :)');
            const json = response.data;
            resolve(json);
          }
        }).then(json => {
          console.log('Four hour');
          console.log(json);
          console.log('ALL');
        });
      });
      c.addEventListener('click', function () {
        new Promise(async (resolve, reject) => {
          try {
            response = await axios.get(`https://api.coincap.io/v2/assets/bitcoin/history?interval=h12`, {
              headers: {
                'Authorization': 'Bearer 96261b71-fe69-46f5-9c5c-c456e1379d8d'
              }
            });
          } catch (ex) {
            console.log('ERROR');
          }
          if (response) {
            console.log('connection...');
            console.log('Sucs...');
            console.log('Already :)');
            const json = response.data;
            resolve(json);
          }
        }).then(json => {
          console.log('Twelve hour');
          console.log(json);
          console.log('ALL');
        });
      });
      d.addEventListener('click', function () {
        new Promise(async (resolve, reject) => {
          try {
            response = await axios.get(`https://api.coincap.io/v2/assets/bitcoin/history?interval=h4`, {
              headers: {
                'Authorization': 'Bearer 96261b71-fe69-46f5-9c5c-c456e1379d8d'
              }
            });
          } catch (ex) {
            console.log('ERROR');
          }
          if (response) {
            console.log('connection...');
            console.log('Sucs...');
            console.log('Already :)');
            const json = response.data;
            resolve(json);
          }
        }).then(json => {
          console.log('Four hour');
          console.log(json);
          console.log('ALL');
        });
      });
      e.addEventListener('click', function () {
        new Promise(async (resolve, reject) => {
          try {
            response = await axios.get(`https://api.coincap.io/v2/assets/bitcoin/history?interval=d1`, {
              headers: {
                'Authorization': 'Bearer 96261b71-fe69-46f5-9c5c-c456e1379d8d'
              }
            });
          } catch (ex) {
            console.log('ERROR');
          }
          if (response) {
            console.log('connection...');
            console.log('Sucs...');
            console.log('Already :)');
            const json = response.data;
            resolve(json);
          }
        }).then(json => {
          console.log('One Day');
          console.log(json);
          console.log('ALL');
        });
      });
      f.addEventListener('click', function () {
        new Promise(async (resolve, reject) => {
          try {
            response = await axios.get(`https://api.coincap.io/v2/assets/bitcoin/history?interval=w1`, {
              headers: {
                'Authorization': 'Bearer 96261b71-fe69-46f5-9c5c-c456e1379d8d'
              }
            });
          } catch (ex) {
            console.log('ERROR');
          }
          if (response) {
            console.log('connection...');
            console.log('Sucs...');
            console.log('Already :)');
            const json = response.data;
            resolve(json);
          }
        }).then(json => {
          console.log('One Week');
          console.log(json);
          console.log('ALL');
        });
      });
    };
    /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sl);
    
    /***/ }),
    
    /***/ "./src/js/modules/updation.js":
    /*!************************************!*\
      !*** ./src/js/modules/updation.js ***!
      \************************************/
    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
    /* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
    /* harmony export */ });
    const upd = () => {
      console.log('up');
      const total = [];
      const gr = [];
      let i = 6;
      const axios = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
      let response = null;
      let response2 = null;
      let response3 = null;
      new Promise(async (resolve, reject) => {
        let src = "https://api.binance.com/api/v3/ticker/price?symbol=BTCUSDT";
        let src2 = "https://api.binance.com/api/v3/ticker/24hr?symbol=BTCUSDT";
        let src3 = "https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1m";
        try {
          response = await axios.get(src, {});
          response2 = await axios.get(src2, {});
          response3 = await axios.get(src3, {});
        } catch (ex) {
          response = null;
          response2 = null;
          response3 = null;
          console.log(ex);
          reject(ex);
        }
        if (response || response2 || response3) {
          console.log('connection...');
          console.log('Sucs...');
          console.log('Already :)');
          const json = response.data.price;
          const json2 = response2.data.priceChangePercent;
          while (i < 40 & i > 0) {
            console.log(gr);
            gr.push(Number(response3.data[response3.data.length - i][4]));
            i--;
          }
          total.push(json);
          total.push(json2);
          console.log(json2);
          resolve(json);
        }
      }).then(an => {
        const BigPr = document.getElementById('wh');
        const BigPerc = document.getElementById('gr');
        let price = parseInt(total[0] * 100) / 100;
        let prc = parseInt(total[1] * 100) / 100;
        let sy = price.toString().includes('.') ? price.toString().split('.').pop().length : 0;
        let sy2 = prc.toString().includes('.') ? prc.toString().split('.').pop().length : 0;
        console.log(sy);
        if (sy === 0) {
          BigPr.textContent = price + '.00';
        } else if (sy === 1) {
          BigPr.textContent = price + '0';
        } else {
          BigPr.textContent = price;
        }
        if (total[1] < 0) {
          BigPerc.className = 'red';
        } else {
          BigPerc.className = 'gr';
        }
        if (sy2 === 0) {
          BigPerc.textContent = prc + '.00%';
        } else if (sy2 === 1) {
          BigPerc.textContent = prc + '0%';
        } else {
          BigPerc.textContent = prc + '%';
        }
      });
      console.log(gr);
      return gr;
    };
    /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (upd);
    
    /***/ }),
    
    /***/ "./node_modules/promise/index.js":
    /*!***************************************!*\
      !*** ./node_modules/promise/index.js ***!
      \***************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    module.exports = __webpack_require__(/*! ./lib */ "./node_modules/promise/lib/index.js")
    
    
    /***/ }),
    
    /***/ "./node_modules/promise/lib/core.js":
    /*!******************************************!*\
      !*** ./node_modules/promise/lib/core.js ***!
      \******************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    var asap = __webpack_require__(/*! asap/raw */ "./node_modules/asap/browser-raw.js");
    
    function noop() {}
    
    // States:
    //
    // 0 - pending
    // 1 - fulfilled with _value
    // 2 - rejected with _value
    // 3 - adopted the state of another promise, _value
    //
    // once the state is no longer pending (0) it is immutable
    
    // All `_` prefixed properties will be reduced to `_{random number}`
    // at build time to obfuscate them and discourage their use.
    // We don't use symbols or Object.defineProperty to fully hide them
    // because the performance isn't good enough.
    
    
    // to avoid using try/catch inside critical functions, we
    // extract them to here.
    var LAST_ERROR = null;
    var IS_ERROR = {};
    function getThen(obj) {
      try {
        return obj.then;
      } catch (ex) {
        LAST_ERROR = ex;
        return IS_ERROR;
      }
    }
    
    function tryCallOne(fn, a) {
      try {
        return fn(a);
      } catch (ex) {
        LAST_ERROR = ex;
        return IS_ERROR;
      }
    }
    function tryCallTwo(fn, a, b) {
      try {
        fn(a, b);
      } catch (ex) {
        LAST_ERROR = ex;
        return IS_ERROR;
      }
    }
    
    module.exports = Promise;
    
    function Promise(fn) {
      if (typeof this !== 'object') {
        throw new TypeError('Promises must be constructed via new');
      }
      if (typeof fn !== 'function') {
        throw new TypeError('Promise constructor\'s argument is not a function');
      }
      this._x = 0;
      this._y = 0;
      this._z = null;
      this._A = null;
      if (fn === noop) return;
      doResolve(fn, this);
    }
    Promise._B = null;
    Promise._C = null;
    Promise._D = noop;
    
    Promise.prototype.then = function(onFulfilled, onRejected) {
      if (this.constructor !== Promise) {
        return safeThen(this, onFulfilled, onRejected);
      }
      var res = new Promise(noop);
      handle(this, new Handler(onFulfilled, onRejected, res));
      return res;
    };
    
    function safeThen(self, onFulfilled, onRejected) {
      return new self.constructor(function (resolve, reject) {
        var res = new Promise(noop);
        res.then(resolve, reject);
        handle(self, new Handler(onFulfilled, onRejected, res));
      });
    }
    function handle(self, deferred) {
      while (self._y === 3) {
        self = self._z;
      }
      if (Promise._B) {
        Promise._B(self);
      }
      if (self._y === 0) {
        if (self._x === 0) {
          self._x = 1;
          self._A = deferred;
          return;
        }
        if (self._x === 1) {
          self._x = 2;
          self._A = [self._A, deferred];
          return;
        }
        self._A.push(deferred);
        return;
      }
      handleResolved(self, deferred);
    }
    
    function handleResolved(self, deferred) {
      asap(function() {
        var cb = self._y === 1 ? deferred.onFulfilled : deferred.onRejected;
        if (cb === null) {
          if (self._y === 1) {
            resolve(deferred.promise, self._z);
          } else {
            reject(deferred.promise, self._z);
          }
          return;
        }
        var ret = tryCallOne(cb, self._z);
        if (ret === IS_ERROR) {
          reject(deferred.promise, LAST_ERROR);
        } else {
          resolve(deferred.promise, ret);
        }
      });
    }
    function resolve(self, newValue) {
      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
      if (newValue === self) {
        return reject(
          self,
          new TypeError('A promise cannot be resolved with itself.')
        );
      }
      if (
        newValue &&
        (typeof newValue === 'object' || typeof newValue === 'function')
      ) {
        var then = getThen(newValue);
        if (then === IS_ERROR) {
          return reject(self, LAST_ERROR);
        }
        if (
          then === self.then &&
          newValue instanceof Promise
        ) {
          self._y = 3;
          self._z = newValue;
          finale(self);
          return;
        } else if (typeof then === 'function') {
          doResolve(then.bind(newValue), self);
          return;
        }
      }
      self._y = 1;
      self._z = newValue;
      finale(self);
    }
    
    function reject(self, newValue) {
      self._y = 2;
      self._z = newValue;
      if (Promise._C) {
        Promise._C(self, newValue);
      }
      finale(self);
    }
    function finale(self) {
      if (self._x === 1) {
        handle(self, self._A);
        self._A = null;
      }
      if (self._x === 2) {
        for (var i = 0; i < self._A.length; i++) {
          handle(self, self._A[i]);
        }
        self._A = null;
      }
    }
    
    function Handler(onFulfilled, onRejected, promise){
      this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
      this.onRejected = typeof onRejected === 'function' ? onRejected : null;
      this.promise = promise;
    }
    
    /**
     * Take a potentially misbehaving resolver function and make sure
     * onFulfilled and onRejected are only called once.
     *
     * Makes no guarantees about asynchrony.
     */
    function doResolve(fn, promise) {
      var done = false;
      var res = tryCallTwo(fn, function (value) {
        if (done) return;
        done = true;
        resolve(promise, value);
      }, function (reason) {
        if (done) return;
        done = true;
        reject(promise, reason);
      });
      if (!done && res === IS_ERROR) {
        done = true;
        reject(promise, LAST_ERROR);
      }
    }
    
    
    /***/ }),
    
    /***/ "./node_modules/promise/lib/done.js":
    /*!******************************************!*\
      !*** ./node_modules/promise/lib/done.js ***!
      \******************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    var Promise = __webpack_require__(/*! ./core.js */ "./node_modules/promise/lib/core.js");
    
    module.exports = Promise;
    Promise.prototype.done = function (onFulfilled, onRejected) {
      var self = arguments.length ? this.then.apply(this, arguments) : this;
      self.then(null, function (err) {
        setTimeout(function () {
          throw err;
        }, 0);
      });
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/promise/lib/es6-extensions.js":
    /*!****************************************************!*\
      !*** ./node_modules/promise/lib/es6-extensions.js ***!
      \****************************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    //This file contains the ES6 extensions to the core Promises/A+ API
    
    var Promise = __webpack_require__(/*! ./core.js */ "./node_modules/promise/lib/core.js");
    
    module.exports = Promise;
    
    /* Static Functions */
    
    var TRUE = valuePromise(true);
    var FALSE = valuePromise(false);
    var NULL = valuePromise(null);
    var UNDEFINED = valuePromise(undefined);
    var ZERO = valuePromise(0);
    var EMPTYSTRING = valuePromise('');
    
    function valuePromise(value) {
      var p = new Promise(Promise._D);
      p._y = 1;
      p._z = value;
      return p;
    }
    Promise.resolve = function (value) {
      if (value instanceof Promise) return value;
    
      if (value === null) return NULL;
      if (value === undefined) return UNDEFINED;
      if (value === true) return TRUE;
      if (value === false) return FALSE;
      if (value === 0) return ZERO;
      if (value === '') return EMPTYSTRING;
    
      if (typeof value === 'object' || typeof value === 'function') {
        try {
          var then = value.then;
          if (typeof then === 'function') {
            return new Promise(then.bind(value));
          }
        } catch (ex) {
          return new Promise(function (resolve, reject) {
            reject(ex);
          });
        }
      }
      return valuePromise(value);
    };
    
    var iterableToArray = function (iterable) {
      if (typeof Array.from === 'function') {
        // ES2015+, iterables exist
        iterableToArray = Array.from;
        return Array.from(iterable);
      }
    
      // ES5, only arrays and array-likes exist
      iterableToArray = function (x) { return Array.prototype.slice.call(x); };
      return Array.prototype.slice.call(iterable);
    }
    
    Promise.all = function (arr) {
      var args = iterableToArray(arr);
    
      return new Promise(function (resolve, reject) {
        if (args.length === 0) return resolve([]);
        var remaining = args.length;
        function res(i, val) {
          if (val && (typeof val === 'object' || typeof val === 'function')) {
            if (val instanceof Promise && val.then === Promise.prototype.then) {
              while (val._y === 3) {
                val = val._z;
              }
              if (val._y === 1) return res(i, val._z);
              if (val._y === 2) reject(val._z);
              val.then(function (val) {
                res(i, val);
              }, reject);
              return;
            } else {
              var then = val.then;
              if (typeof then === 'function') {
                var p = new Promise(then.bind(val));
                p.then(function (val) {
                  res(i, val);
                }, reject);
                return;
              }
            }
          }
          args[i] = val;
          if (--remaining === 0) {
            resolve(args);
          }
        }
        for (var i = 0; i < args.length; i++) {
          res(i, args[i]);
        }
      });
    };
    
    function onSettledFulfill(value) {
      return { status: 'fulfilled', value: value };
    }
    function onSettledReject(reason) {
      return { status: 'rejected', reason: reason };
    }
    function mapAllSettled(item) {
      if(item && (typeof item === 'object' || typeof item === 'function')){
        if(item instanceof Promise && item.then === Promise.prototype.then){
          return item.then(onSettledFulfill, onSettledReject);
        }
        var then = item.then;
        if (typeof then === 'function') {
          return new Promise(then.bind(item)).then(onSettledFulfill, onSettledReject)
        }
      }
    
      return onSettledFulfill(item);
    }
    Promise.allSettled = function (iterable) {
      return Promise.all(iterableToArray(iterable).map(mapAllSettled));
    };
    
    Promise.reject = function (value) {
      return new Promise(function (resolve, reject) {
        reject(value);
      });
    };
    
    Promise.race = function (values) {
      return new Promise(function (resolve, reject) {
        iterableToArray(values).forEach(function(value){
          Promise.resolve(value).then(resolve, reject);
        });
      });
    };
    
    /* Prototype Methods */
    
    Promise.prototype['catch'] = function (onRejected) {
      return this.then(null, onRejected);
    };
    
    function getAggregateError(errors){
      if(typeof AggregateError === 'function'){
        return new AggregateError(errors,'All promises were rejected');
      }
    
      var error = new Error('All promises were rejected');
    
      error.name = 'AggregateError';
      error.errors = errors;
    
      return error;
    }
    
    Promise.any = function promiseAny(values) {
      return new Promise(function(resolve, reject) {
        var promises = iterableToArray(values);
        var hasResolved = false;
        var rejectionReasons = [];
    
        function resolveOnce(value) {
          if (!hasResolved) {
            hasResolved = true;
            resolve(value);
          }
        }
    
        function rejectionCheck(reason) {
          rejectionReasons.push(reason);
    
          if (rejectionReasons.length === promises.length) {
            reject(getAggregateError(rejectionReasons));
          }
        }
    
        if(promises.length === 0){
          reject(getAggregateError(rejectionReasons));
        } else {
          promises.forEach(function(value){
            Promise.resolve(value).then(resolveOnce, rejectionCheck);
          });
        }
      });
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/promise/lib/finally.js":
    /*!*********************************************!*\
      !*** ./node_modules/promise/lib/finally.js ***!
      \*********************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    var Promise = __webpack_require__(/*! ./core.js */ "./node_modules/promise/lib/core.js");
    
    module.exports = Promise;
    Promise.prototype.finally = function (f) {
      return this.then(function (value) {
        return Promise.resolve(f()).then(function () {
          return value;
        });
      }, function (err) {
        return Promise.resolve(f()).then(function () {
          throw err;
        });
      });
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/promise/lib/index.js":
    /*!*******************************************!*\
      !*** ./node_modules/promise/lib/index.js ***!
      \*******************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    module.exports = __webpack_require__(/*! ./core.js */ "./node_modules/promise/lib/core.js");
    __webpack_require__(/*! ./done.js */ "./node_modules/promise/lib/done.js");
    __webpack_require__(/*! ./finally.js */ "./node_modules/promise/lib/finally.js");
    __webpack_require__(/*! ./es6-extensions.js */ "./node_modules/promise/lib/es6-extensions.js");
    __webpack_require__(/*! ./node-extensions.js */ "./node_modules/promise/lib/node-extensions.js");
    __webpack_require__(/*! ./synchronous.js */ "./node_modules/promise/lib/synchronous.js");
    
    
    /***/ }),
    
    /***/ "./node_modules/promise/lib/node-extensions.js":
    /*!*****************************************************!*\
      !*** ./node_modules/promise/lib/node-extensions.js ***!
      \*****************************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    // This file contains then/promise specific extensions that are only useful
    // for node.js interop
    
    var Promise = __webpack_require__(/*! ./core.js */ "./node_modules/promise/lib/core.js");
    var asap = __webpack_require__(/*! asap */ "./node_modules/asap/browser-asap.js");
    
    module.exports = Promise;
    
    /* Static Functions */
    
    Promise.denodeify = function (fn, argumentCount) {
      if (
        typeof argumentCount === 'number' && argumentCount !== Infinity
      ) {
        return denodeifyWithCount(fn, argumentCount);
      } else {
        return denodeifyWithoutCount(fn);
      }
    };
    
    var callbackFn = (
      'function (err, res) {' +
      'if (err) { rj(err); } else { rs(res); }' +
      '}'
    );
    function denodeifyWithCount(fn, argumentCount) {
      var args = [];
      for (var i = 0; i < argumentCount; i++) {
        args.push('a' + i);
      }
      var body = [
        'return function (' + args.join(',') + ') {',
        'var self = this;',
        'return new Promise(function (rs, rj) {',
        'var res = fn.call(',
        ['self'].concat(args).concat([callbackFn]).join(','),
        ');',
        'if (res &&',
        '(typeof res === "object" || typeof res === "function") &&',
        'typeof res.then === "function"',
        ') {rs(res);}',
        '});',
        '};'
      ].join('');
      return Function(['Promise', 'fn'], body)(Promise, fn);
    }
    function denodeifyWithoutCount(fn) {
      var fnLength = Math.max(fn.length - 1, 3);
      var args = [];
      for (var i = 0; i < fnLength; i++) {
        args.push('a' + i);
      }
      var body = [
        'return function (' + args.join(',') + ') {',
        'var self = this;',
        'var args;',
        'var argLength = arguments.length;',
        'if (arguments.length > ' + fnLength + ') {',
        'args = new Array(arguments.length + 1);',
        'for (var i = 0; i < arguments.length; i++) {',
        'args[i] = arguments[i];',
        '}',
        '}',
        'return new Promise(function (rs, rj) {',
        'var cb = ' + callbackFn + ';',
        'var res;',
        'switch (argLength) {',
        args.concat(['extra']).map(function (_, index) {
          return (
            'case ' + (index) + ':' +
            'res = fn.call(' + ['self'].concat(args.slice(0, index)).concat('cb').join(',') + ');' +
            'break;'
          );
        }).join(''),
        'default:',
        'args[argLength] = cb;',
        'res = fn.apply(self, args);',
        '}',
        
        'if (res &&',
        '(typeof res === "object" || typeof res === "function") &&',
        'typeof res.then === "function"',
        ') {rs(res);}',
        '});',
        '};'
      ].join('');
    
      return Function(
        ['Promise', 'fn'],
        body
      )(Promise, fn);
    }
    
    Promise.nodeify = function (fn) {
      return function () {
        var args = Array.prototype.slice.call(arguments);
        var callback =
          typeof args[args.length - 1] === 'function' ? args.pop() : null;
        var ctx = this;
        try {
          return fn.apply(this, arguments).nodeify(callback, ctx);
        } catch (ex) {
          if (callback === null || typeof callback == 'undefined') {
            return new Promise(function (resolve, reject) {
              reject(ex);
            });
          } else {
            asap(function () {
              callback.call(ctx, ex);
            })
          }
        }
      }
    };
    
    Promise.prototype.nodeify = function (callback, ctx) {
      if (typeof callback != 'function') return this;
    
      this.then(function (value) {
        asap(function () {
          callback.call(ctx, null, value);
        });
      }, function (err) {
        asap(function () {
          callback.call(ctx, err);
        });
      });
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/promise/lib/synchronous.js":
    /*!*************************************************!*\
      !*** ./node_modules/promise/lib/synchronous.js ***!
      \*************************************************/
    /***/ ((module, __unused_webpack_exports, __webpack_require__) => {
    
    "use strict";
    
    
    var Promise = __webpack_require__(/*! ./core.js */ "./node_modules/promise/lib/core.js");
    
    module.exports = Promise;
    Promise.enableSynchronous = function () {
      Promise.prototype.isPending = function() {
        return this.getState() == 0;
      };
    
      Promise.prototype.isFulfilled = function() {
        return this.getState() == 1;
      };
    
      Promise.prototype.isRejected = function() {
        return this.getState() == 2;
      };
    
      Promise.prototype.getValue = function () {
        if (this._y === 3) {
          return this._z.getValue();
        }
    
        if (!this.isFulfilled()) {
          throw new Error('Cannot get a value of an unfulfilled promise.');
        }
    
        return this._z;
      };
    
      Promise.prototype.getReason = function () {
        if (this._y === 3) {
          return this._z.getReason();
        }
    
        if (!this.isRejected()) {
          throw new Error('Cannot get a rejection reason of a non-rejected promise.');
        }
    
        return this._z;
      };
    
      Promise.prototype.getState = function () {
        if (this._y === 3) {
          return this._z.getState();
        }
        if (this._y === -1 || this._y === -2) {
          return 0;
        }
    
        return this._y;
      };
    };
    
    Promise.disableSynchronous = function() {
      Promise.prototype.isPending = undefined;
      Promise.prototype.isFulfilled = undefined;
      Promise.prototype.isRejected = undefined;
      Promise.prototype.getValue = undefined;
      Promise.prototype.getReason = undefined;
      Promise.prototype.getState = undefined;
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/package.json":
    /*!*****************************************!*\
      !*** ./node_modules/axios/package.json ***!
      \*****************************************/
    /***/ ((module) => {
    
    "use strict";
    module.exports = /*#__PURE__*/JSON.parse('{"name":"axios","version":"0.21.4","description":"Promise based HTTP client for the browser and node.js","main":"index.js","scripts":{"test":"grunt test","start":"node ./sandbox/server.js","build":"NODE_ENV=production grunt build","preversion":"npm test","version":"npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json","postversion":"git push && git push --tags","examples":"node ./examples/server.js","coveralls":"cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js","fix":"eslint --fix lib/**/*.js"},"repository":{"type":"git","url":"https://github.com/axios/axios.git"},"keywords":["xhr","http","ajax","promise","node"],"author":"Matt Zabriskie","license":"MIT","bugs":{"url":"https://github.com/axios/axios/issues"},"homepage":"https://axios-http.com","devDependencies":{"coveralls":"^3.0.0","es6-promise":"^4.2.4","grunt":"^1.3.0","grunt-banner":"^0.6.0","grunt-cli":"^1.2.0","grunt-contrib-clean":"^1.1.0","grunt-contrib-watch":"^1.0.0","grunt-eslint":"^23.0.0","grunt-karma":"^4.0.0","grunt-mocha-test":"^0.13.3","grunt-ts":"^6.0.0-beta.19","grunt-webpack":"^4.0.2","istanbul-instrumenter-loader":"^1.0.0","jasmine-core":"^2.4.1","karma":"^6.3.2","karma-chrome-launcher":"^3.1.0","karma-firefox-launcher":"^2.1.0","karma-jasmine":"^1.1.1","karma-jasmine-ajax":"^0.1.13","karma-safari-launcher":"^1.0.0","karma-sauce-launcher":"^4.3.6","karma-sinon":"^1.0.5","karma-sourcemap-loader":"^0.3.8","karma-webpack":"^4.0.2","load-grunt-tasks":"^3.5.2","minimist":"^1.2.0","mocha":"^8.2.1","sinon":"^4.5.0","terser-webpack-plugin":"^4.2.3","typescript":"^4.0.5","url-search-params":"^0.10.0","webpack":"^4.44.2","webpack-dev-server":"^3.11.0"},"browser":{"./lib/adapters/http.js":"./lib/adapters/xhr.js"},"jsdelivr":"dist/axios.min.js","unpkg":"dist/axios.min.js","typings":"./index.d.ts","dependencies":{"follow-redirects":"^1.14.0"},"bundlesize":[{"path":"./dist/axios.min.js","threshold":"5kB"}]}');
    
    /***/ })
    
    /******/ 	});
    /************************************************************************/
    /******/ 	// The module cache
    /******/ 	var __webpack_module_cache__ = {};
    /******/ 	
    /******/ 	// The require function
    /******/ 	function __webpack_require__(moduleId) {
    /******/ 		// Check if module is in cache
    /******/ 		var cachedModule = __webpack_module_cache__[moduleId];
    /******/ 		if (cachedModule !== undefined) {
    /******/ 			return cachedModule.exports;
    /******/ 		}
    /******/ 		// Create a new module (and put it into the cache)
    /******/ 		var module = __webpack_module_cache__[moduleId] = {
    /******/ 			// no module.id needed
    /******/ 			// no module.loaded needed
    /******/ 			exports: {}
    /******/ 		};
    /******/ 	
    /******/ 		// Execute the module function
    /******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
    /******/ 	
    /******/ 		// Return the exports of the module
    /******/ 		return module.exports;
    /******/ 	}
    /******/ 	
    /************************************************************************/
    /******/ 	/* webpack/runtime/compat get default export */
    /******/ 	(() => {
    /******/ 		// getDefaultExport function for compatibility with non-harmony modules
    /******/ 		__webpack_require__.n = (module) => {
    /******/ 			var getter = module && module.__esModule ?
    /******/ 				() => (module['default']) :
    /******/ 				() => (module);
    /******/ 			__webpack_require__.d(getter, { a: getter });
    /******/ 			return getter;
    /******/ 		};
    /******/ 	})();
    /******/ 	
    /******/ 	/* webpack/runtime/define property getters */
    /******/ 	(() => {
    /******/ 		// define getter functions for harmony exports
    /******/ 		__webpack_require__.d = (exports, definition) => {
    /******/ 			for(var key in definition) {
    /******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
    /******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
    /******/ 				}
    /******/ 			}
    /******/ 		};
    /******/ 	})();
    /******/ 	
    /******/ 	/* webpack/runtime/global */
    /******/ 	(() => {
    /******/ 		__webpack_require__.g = (function() {
    /******/ 			if (typeof globalThis === 'object') return globalThis;
    /******/ 			try {
    /******/ 				return this || new Function('return this')();
    /******/ 			} catch (e) {
    /******/ 				if (typeof window === 'object') return window;
    /******/ 			}
    /******/ 		})();
    /******/ 	})();
    /******/ 	
    /******/ 	/* webpack/runtime/hasOwnProperty shorthand */
    /******/ 	(() => {
    /******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
    /******/ 	})();
    /******/ 	
    /******/ 	/* webpack/runtime/make namespace object */
    /******/ 	(() => {
    /******/ 		// define __esModule on exports
    /******/ 		__webpack_require__.r = (exports) => {
    /******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
    /******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
    /******/ 			}
    /******/ 			Object.defineProperty(exports, '__esModule', { value: true });
    /******/ 		};
    /******/ 	})();
    /******/ 	
    /************************************************************************/
    var __webpack_exports__ = {};
    // This entry need to be wrapped in an IIFE because it need to be in strict mode.
    (() => {
    "use strict";
    /*!************************!*\
      !*** ./src/js/main.js ***!
      \************************/
    __webpack_require__.r(__webpack_exports__);
    /* harmony import */ var _modules_pr_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modules/pr.js */ "./src/js/modules/pr.js");
    /* harmony import */ var _modules_sl_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/sl.js */ "./src/js/modules/sl.js");
    /* harmony import */ var _modules_graph_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modules/graph.js */ "./src/js/modules/graph.js");
    /* harmony import */ var _modules_updation_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modules/updation.js */ "./src/js/modules/updation.js");
    /* harmony import */ var _modules_newgraph_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modules/newgraph.js */ "./src/js/modules/newgraph.js");
    
    
    
    
    
    window.addEventListener('DOMContentLoaded', () => {
      (0,_modules_sl_js__WEBPACK_IMPORTED_MODULE_1__["default"])();
      (0,_modules_newgraph_js__WEBPACK_IMPORTED_MODULE_4__["default"])();
      setInterval(function () {
        (0,_modules_updation_js__WEBPACK_IMPORTED_MODULE_3__["default"])();
      }, 1000);
    });
    })();
    
    /******/ })()
    ;
    //# sourceMappingURL=script.js.map